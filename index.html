<html>
  <head>
    <title>Pynamo: Exploring the Dynamo Paper in Python</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="author" content="David Drysdale">
    <meta name="keywords" content="drysdale, Dynamo, Python">
    <link rel="stylesheet" href="pygments.css" />
    <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23228806-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
    </script>
  </head>
  <body>
    <h1>Pynamo: Exploring the Dynamo Paper in Python</h1>
    <p>
      The
      <a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf">original paper
      [PDF]</a> that describes Amazon's Dynamo system is extremely interesting, and clearly explained.  This
      page documents my attempt to create a bare-bones Python implementation of the key ideas from the Dynamo
      paper.
    </p>
    <p>
      My aim here is to use the process of writing code as a way of understanding the relevant ideas better
      &ndash; in other words the code here is
      <b>pedagogical</b> rather than practical.  For example,  I deliberately use inefficent
      implementations in places &ndash; I'd rather have a slow implementation that just uses the Python standard
      library, than a fast version with distractions (by either requiring additional <code>import</code>s, or
      by including implementations of data structure that aren't specific to Dynamo).
    </p>
    <p>
      I've also built the system on top of a simulated network, rather than on top of a real network or web
      server.  This means I can more easily test different scenarios and track what's going on (more on the
      framework <a href="#framework">at the end</a>).
    </p>
    <p>
      For my final proviso, I should point out that I'm not going to explain much about the original ideas in
      the Dynamo paper, which are generally explained perfectly clearly.  In other words, this page <b>assumes
      you're read the original paper</b> and that you have it close to hand when you're reading this.
    </p>
    <p>
      Structurally, we'll start by exploring some of the building blocks used in the design, then start
      building up the Dynamo software step by step.
    </p>

    <h3>Contents</h3>
    <ul>
      <li><a href="#consistent_hash">Building Block: Consistent Hashing (s4.2/s4.3)</a></li>
      <li><a href="#simple_put"><b>Put</b>ting It Together</a></li>
      <li><a href="#simple_get"><b>Get</b>ting it Back</a></li>
      <li><a href="#failure">Coping With Failure</a></li>
      <li><a href="#faildetect">Node Failure Detection (s4.8.3)</a></li>
      <li><a href="#failrecover">Node Recovery Detection</a></li>
      <li><a href="#hintedhandoff">Hinted Handoff</a></li>
      <!-- 
      <li><a href="#merkle">Building Block: Merkle Trees (s4.7)</a></li>
      <li><a href="#catchup">Catchup</a></li>
      -->
      <li><a href="#vector_clock">Building Block: Vector Clocks (s4.4)</a></li>
      <li><a href="#divergence">Detecting Divergence</a></li>
      <li><a href="#divergence_repair">Repairing Divergence</a></li>
      <li><a href="#rest">What's Left</a></li>

      <li><a href="#framework">Appendix: Node Simulation Framework</a></li>
      <li><a href="#epilog">Epilog: Code Location &amp; Licenses</a></li>
    </ul>


    <a name="consistent_hash"><h2>Building Block: Consistent Hashing (s4.2/s4.3)</h2></a>
    <p>
      The first area to explore is the consistent hashing algorithm described in section 4.2 of the paper.
      The constructor for the <code>ConsistentHashTable</code> class builds up the list of nodes, and the
      <code>find_nodes</code> method returns the <i>preference list</i> of nodes for the key (where the first
      entry in the list is the <i>coordinator</i>).
    </p>
    <p>
      The first implementation just implements the straightforward one-hash-per-node approach:
    </p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Consistent hash code&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">binascii</span>
<span class="kn">import</span> <span class="nn">bisect</span>


<span class="k">class</span> <span class="nc">SimpleConsistentHashTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a consistent hash table for the given list of nodes&quot;&quot;&quot;</span>
        <span class="n">baselist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="o">.</span><span class="n">digest</span><span class="p">(),</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">]</span>
        <span class="c1"># Build two lists: one of (hashvalue, node) pairs, sorted by</span>
        <span class="c1"># hashvalue, one of just the hashvalues, to allow use of bisect.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">baselist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hashlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">hashnode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">hashnode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">find_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">avoid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of count nodes from the hash table that are</span>
<span class="sd">        consecutively after the hash of the given key, together with</span>
<span class="sd">        those nodes from the avoid collection that have been avoided.</span>

<span class="sd">        Returned list size is &lt;= count, and any nodes in the avoid collection</span>
<span class="sd">        are not included.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">avoid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Use an empty set</span>
            <span class="n">avoid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Hash the key to find where it belongs on the ring</span>
        <span class="n">hv</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
        <span class="c1"># Find the node after this hash value around the ring, as an index</span>
        <span class="c1"># into self.hashlist/self.nodelist</span>
        <span class="n">initial_index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashlist</span><span class="p">,</span> <span class="n">hv</span><span class="p">)</span>
        <span class="n">next_index</span> <span class="o">=</span> <span class="n">initial_index</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">avoided</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">):</span>  <span class="c1"># Wrap round to the start</span>
                <span class="n">next_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">avoid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">avoided</span><span class="p">:</span>
                    <span class="n">avoided</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">next_index</span> <span class="o">=</span> <span class="n">next_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">next_index</span> <span class="o">==</span> <span class="n">initial_index</span><span class="p">:</span>
                <span class="c1"># Gone all the way around -- terminate loop regardless</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="n">avoided</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="n">nodeinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">nodeinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">nodeinfo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">])</span>
</pre></div>

    <p>
      The paper indicates a couple of problems with this simplistic approach, which we can check by feeding
      in some random data:
    </p>
    <ul>
      <li><b>The distribution of hash values can be 'lumpy'</b>:
10000 random hash keys assigned to 50 nodes are distributed across the nodes with a standard deviation of 168.39 (compared to a mean of 200).       </li>
      <li><b>All of the traffic of a failed node moves to a single other node</b>:
        Adding a node to the <code>avoid</code> parameter means that the (single) next node round the
        hash ring gets all of the keys that would have gone to the failed node.
      </li>
    </ul>
    <p>
      So we move to the second implementation, where each node gets multiple points in the hash ring, known
      as <i>virtual nodes</i>.  We implement this very simply, by adding a ":<i>&lt;count&gt;</i>" suffix to
      the string that we hash for the node position.
    </p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Consistent hash code&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">binascii</span>
<span class="kn">import</span> <span class="nn">bisect</span>


<span class="k">class</span> <span class="nc">ConsistentHashTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">repeat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a consistent hash table for the given list of nodes&quot;&quot;&quot;</span>
        <span class="c1"># Insert each node into the hash circle multiple times</span>
        <span class="n">baselist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">repeat</span><span class="p">):</span>
                <span class="n">nodestring</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
                <span class="n">baselist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">nodestring</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">(),</span> <span class="n">node</span><span class="p">))</span>
        <span class="c1"># Build two lists: one of (hashvalue, node) pairs, sorted by</span>
        <span class="c1"># hashvalue, one of just the hashvalues, to allow use of bisect.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">baselist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hashlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">hashnode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">hashnode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">find_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">avoid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of count nodes from the hash table that are</span>
<span class="sd">        consecutively after the hash of the given key, together with</span>
<span class="sd">        those nodes from the avoid collection that have been avoided.</span>

<span class="sd">        Returned list size is &lt;= count, and any nodes in the avoid collection</span>
<span class="sd">        are not included.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">avoid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Use an empty set</span>
            <span class="n">avoid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Hash the key to find where it belongs on the ring</span>
        <span class="n">hv</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
        <span class="c1"># Find the node after this hash value around the ring, as an index</span>
        <span class="c1"># into self.hashlist/self.nodelist</span>
        <span class="n">initial_index</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashlist</span><span class="p">,</span> <span class="n">hv</span><span class="p">)</span>
        <span class="n">next_index</span> <span class="o">=</span> <span class="n">initial_index</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">avoided</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">):</span>  <span class="c1"># Wrap round to the start</span>
                <span class="n">next_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">[</span><span class="n">next_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">avoid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">avoided</span><span class="p">:</span>
                    <span class="n">avoided</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">next_index</span> <span class="o">=</span> <span class="n">next_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">next_index</span> <span class="o">==</span> <span class="n">initial_index</span><span class="p">:</span>
                <span class="c1"># Gone all the way around -- terminate loop regardless</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="n">avoided</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="n">nodeinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">nodeinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">nodeinfo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodelist</span><span class="p">])</span>
</pre></div>

    <p>
      Let's see how much different this makes by feeding in some random data to a set of 50 nodes with 10
      copies of each node in the hash ring.
    </p>
    <ul>
      <li><b>Distribution of hash values</b>:
10000 random hash keys assigned to 50 nodes each repeated 10 times are distributed across the nodes with a standard deviation of 63.89 (compared to a mean of 200).       </li>
      <li><b>Distribution of traffic from a failed node</b>:
On failure of a single node, 8.6 other nodes (on average) handle the transferred traffic from that node.       </li>
   </ul>
    <p>
      For 50 nodes with <b>100</b> copies of each node in the hash ring.
    </p>
    <ul>
      <li><b>Distribution of hash values</b>:
10000 random hash keys assigned to 50 nodes each repeated 100 times are distributed across the nodes with a standard deviation of 32.84 (compared to a mean of 200).       </li>
      <li><b>Distribution of traffic from a failed node</b>:
On failure of a single node, 35.1 other nodes (on average) handle the transferred traffic from that node.       </li>
    </ul>
    <p>
      So the multiple node approach has lead to a much less 'lumpy' distribution of keys.
    </p>


    <a name="simple_put"><h2><b>Put</b>ting It Together</h2></a>
    <p>
      Now we're going to start to put everything together.  We're going to build on a simulated enviroment of
      nodes and messages between them, which allows testing and simulation.  The framework is described in
      more detail in the <a href="#framework">appendix</a>, but hopefully the framework's methods are clear
      enough not to need much explanation.
    </p>
    <p>
      First up, let's simulate a client that wants to use the Dynamo system.  Equivalently to section 4.1 of
      the paper, it has two methods: <code>put(key, context, value)</code> and <code>get(key)</code>.  The
      client is outside of the Dynamo system proper, so these methods are straightforward: build the
      appropriate message and send it to a random node in the Dynamo system (although this can be overridden
      with an explicit choice of node).
    </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DynamoClientNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">destnode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">destnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Pick a random node to send the request to</span>
            <span class="n">destnode</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">)</span>
        <span class="n">putmsg</span> <span class="o">=</span> <span class="n">ClientPut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destnode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
        <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">destnode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">destnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Pick a random node to send the request to</span>
            <span class="n">destnode</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">)</span>
        <span class="n">getmsg</span> <span class="o">=</span> <span class="n">ClientGet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destnode</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">getmsg</span><span class="p">)</span>
</pre></div>

    <p>
      These messages are sent to a <code>DynamoNode</code>, whose definition includes some data structures.  The
      class includes some constants controlling the amount of replication, including the <b>N</b>, <b>W</b>
      and <b>R</b> parameters described in section 4.5 of the paper.  The class also keeps track of how many
      <code>DynamoNode</code> instances there are, and keeps a
      <a href="#consistent_hash">consistent hash table</a> that corresponds to those instances.
    </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DynamoNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Number of repeats for nodes in consistent hash table</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Number of nodes to replicate at</span>
    <span class="n">W</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of nodes that need to reply to a write operation</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of nodes that need to reply to a read operation</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chash</span> <span class="o">=</span> <span class="n">ConsistentHashTable</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DynamoNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_store</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key =&gt; (value, metadata)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; set of nodes that have stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; original client message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; set of (node, value, metadata) tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; original client message</span>
        <span class="c1"># Rebuild the consistent hash table</span>
        <span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span> <span class="o">=</span> <span class="n">ConsistentHashTable</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>

    <p>
      Each instance of <code>DynamoNode</code> has some attributes of its own.  The <code>local_store</code>
      attribute is a Python dictionary that simulates the node's local data store; this is where the key/value
      pairs stored by the system end up.  There are also a <code>pending_put</code>
      and <code>pending_get</code> data structures that keep track of pending operations being coordinated by
      this node.
    </p>
    <p>
      Access to the local data store <code>local_store</code> is via the <code>store()</code>
      and <code>retrieve()</code> methods; this will allow us to substitute in more sophisticated
      functionality later.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_store</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>

    <p>
      So what happens when a client tries to <code>put()</code> a piece of data?  The initial request message
      will arrive at a random Dynamo node, and its first action is to figure out the <i>preference list</i>.
      <ul>
        <li>If the local node isn't in the preference list, it forwards the request on to a node that is in
          the list (specifically, the <i>coordinator</i> &ndash; the first node on the list).</li>
        <li>If the local node is in the preference list, then it sends a
          <b>Put</b> message to the N nodes (including itself) to get them to store the data.</li>
      </ul>
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rcv_clientput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Determine if we are in the list</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
            <span class="c1"># Forward to the coordinator for this key</span>
            <span class="n">coordinator</span> <span class="o">=</span> <span class="n">preference_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Framework</span><span class="o">.</span><span class="n">forward_message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">coordinator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use an incrementing local sequence number to distinguish</span>
            <span class="c1"># multiple requests for the same key</span>
            <span class="n">seqno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sequence_number</span><span class="p">()</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span>  <span class="c1"># For now, metadata is just sequence number at coordinator</span>
            <span class="c1"># Send out to preference list, and keep track of who has replied</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="n">reqcount</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
                <span class="c1"># Send message to get node in preference list to store</span>
                <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">)</span>
                <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                <span class="n">reqcount</span> <span class="o">=</span> <span class="n">reqcount</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">reqcount</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                    <span class="c1"># preference_list may have more than N entries to allow for failed nodes</span>
                    <span class="k">break</span>
</pre></div>

    <p>
      Continuing to follow the progress of a <code>put()</code> operation, the behaviour of the nodes that
      receive the <b>Put</b> messages is straightforward: they store the value, and send a response to say
      they've done it.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rcv_put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">putmsg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">putmsg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">putmsg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">putmsg</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">putrsp</span> <span class="o">=</span> <span class="n">PutRsp</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
        <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putrsp</span><span class="p">)</span>
</pre></div>

    <p>
      In turn, the original sending node ticks off these responses from its list of pending responses, and
      when it has had <b>W</b> total replies (including itself), the <code>put()</code> operation is done.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rcv_putrsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">putrsp</span><span class="p">):</span>
        <span class="n">seqno</span> <span class="o">=</span> <span class="n">putrsp</span><span class="o">.</span><span class="n">msg_id</span>
        <span class="k">if</span> <span class="n">seqno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">putrsp</span><span class="o">.</span><span class="n">from_node</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">W</span><span class="p">:</span>
                <span class="c1"># Tidy up tracking data structures</span>
                <span class="n">original_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                <span class="c1"># Reply to the original client</span>
                <span class="n">client_putrsp</span> <span class="o">=</span> <span class="n">ClientPutRsp</span><span class="p">(</span><span class="n">original_msg</span><span class="p">)</span>
                <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">client_putrsp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Superfluous reply</span>
</pre></div>

    <p>
      We can see an example of the whole process as a ladder diagram. Notice that the response goes back to
      the client before the final <b>Put</b> response arrives &ndash; the <b>N</b> parameter is 3, so
      the <b>Put</b> request is processed by 3 nodes, but the <b>W</b> parameter is only 2 and so the final
      response isn't needed for the process to complete.
    </p>
<div class="highlight"><pre>
A                    B                    C                    D                    a
.                    .                    .                    .   ClientPut(K1=1) +o
<----------------------------------------------------------------------------------+.
++ ClientPut(K1=1)   .                    .                    .                    .
.+------------------------------------------------------------->                    .
.                    .                    .      PutReq(K1=1) +o                    .
.                    .                    .     PutReq(K1=1) +-o                    .
.                    .                    .    PutReq(K1=1) +--o                    .
.                    .                    .                 ||+>                    .
.                    .                    .      PutRsp(K1=1) +o                    .
.                    <---------------------------------------+|.                    .
.                    o+ PutRsp(K1=1)      .                 | |.                    .
.                    .|                   <-----------------+ |.                    .
.                    .|                   o+ PutRsp(K1=1)     |.                    .
.                    .|                   .|                  +>                    .
.                    .+---------------------------------------->                    .
.                    .                    .|                   o+ ClientPutRsp(K1=1).
.                    .                    .+------------------->|                   .
.                    .                    .                    .+------------------->
A                    B                    C                    D                    a
                   K1:1                 K1:1                 K1:1 </pre></div>
    <p>
      Interspersing <b>Put</b> operations for two different keys, from two different clients makes the ladder
      diagram more complicated, but the underlying details are the same.
    </p>
<div class="highlight"><pre>
A              B              C              D              E              F              a              b
.              .              .              .              .            ClientPut(K1=1) +o              .
<----------------------------------------------------------------------------------------+.              .
++ ClientPut(K1=1)            .              .              .              .              .              .
.|             .              .              .              .              .           ClientPut(K2=17) +o
.+------------------------------------------->              .              .              .             |.
.              .              .PutReq(K1=1) +o              .              .              .             |.
.              .              PutReq(K1=1) +-o              .              .              .             |.
.              .             PutReq(K1=1) +--o              .              .              .             |.
.              .              <-------------------------------------------------------------------------+.
.              .              o+ PutReq(K2=17)              .              .              .              .
.              PutReq(K2=17) +o|          |||.              .              .              .              .
.              .             |o-+ PutReq(K2=17)             .              .              .              .
.              .             |.||         ||+>              .              .              .              .
.              .             |.PutRsp(K1=1) +o              .              .              .              .
.              <---------------------------+|.              .              .              .              .
.              o+ PutRsp(K1=1).||         | |.              .              .              .              .
.              .|            |<-----------+ |.              .              .              .              .
.              .|            |o--+ PutRsp(K1=1)             .              .              .              .
.              .|            |.+------------------------------------------->              .              .
.              .|            |. ||          |.              PutRsp(K2=17) +o              .              .
.              .|            +> ||          |.              .             |.              .              .
.              PutRsp(K2=17) +o ||          |.              .             |.              .              .
.              .|            |. +--------------------------->             |.              .              .
.              .|            |.  |          |PutRsp(K2=17) +o             |.              .              .
.              .|            |.  |          +>             |.             |.              .              .
.              .+---------------------------->             |.             |.              .              .
.              .             |.  |           o+ ClientPutRsp(K1=1)        |.              .              .
.              .             |.  +----------->|            |.             |.              .              .
.              .             |<-------------------------------------------+.              .              .
.              .             +>              .|            |.              .              .              .
.              .              o+ ClientPutRsp(K2=17)       |.              .              .              .
.              .              <----------------------------+.              .              .              .
.              .              .|             .+------------------------------------------->              .
.              .              .+------------------------------------------------------------------------->
A              B              C              D              E              F              a              b
             K1:1           K2:17          K1:1           K2:17          K2:17                            
                            K1:1 </pre></div>


    <a name="simple_get"><h2><b>Get</b>ting it Back</h2></a>
    <p>
      After seeing the <b>Put</b> infrastructure, the <b>Get</b> infrastructure is pretty similar.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rcv_clientget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Determine if we are in the list</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
            <span class="c1"># Forward to the coordinator for this key</span>
            <span class="n">coordinator</span> <span class="o">=</span> <span class="n">preference_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Framework</span><span class="o">.</span><span class="n">forward_message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">coordinator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seqno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sequence_number</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="n">reqcount</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
                <span class="n">getmsg</span> <span class="o">=</span> <span class="n">GetReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">)</span>
                <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">getmsg</span><span class="p">)</span>
                <span class="n">reqcount</span> <span class="o">=</span> <span class="n">reqcount</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">reqcount</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                    <span class="c1"># preference_list may have more than N entries to allow for failed nodes</span>
                    <span class="k">break</span>
</pre></div>

    <p>
      Each of those nodes simply retrieves the relevant information from its local data store and sends it
      back.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rcv_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getmsg</span><span class="p">):</span>
        <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">getmsg</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">getrsp</span> <span class="o">=</span> <span class="n">GetRsp</span><span class="p">(</span><span class="n">getmsg</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
        <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">getrsp</span><span class="p">)</span>
</pre></div>

    <p>
      Finally, when enough (i.e. <b>R</b>) responses arrive, the first Dynamo node sends a confirmation response
      back to the client.  This part has a slight complication &ndash; the results aren't necessarily all the same,
      so we return the whole set (folding duplicates).
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rcv_getrsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getrsp</span><span class="p">):</span>
        <span class="n">seqno</span> <span class="o">=</span> <span class="n">getrsp</span><span class="o">.</span><span class="n">msg_id</span>
        <span class="k">if</span> <span class="n">seqno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">getrsp</span><span class="o">.</span><span class="n">from_node</span><span class="p">,</span> <span class="n">getrsp</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">getrsp</span><span class="o">.</span><span class="n">metadata</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">R</span><span class="p">:</span>
                <span class="c1"># Build up all the distinct values/metadata values for the response to the original request</span>
                <span class="n">results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]])</span>
                <span class="c1"># Tidy up tracking data structures</span>
                <span class="n">original_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                <span class="c1"># Reply to the original client, including all received values</span>
                <span class="n">client_getrsp</span> <span class="o">=</span> <span class="n">ClientGetRsp</span><span class="p">(</span><span class="n">original_msg</span><span class="p">,</span>
                                             <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">],</span>
                                             <span class="p">[</span><span class="n">metadata</span> <span class="k">for</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
                <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">client_getrsp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Superfluous reply</span>
</pre></div>

    <p>
      The whole process looks like the following:
    </p>
<div class="highlight"><pre>
A                    B                    C                    D                    a
.                    .                    .                    .   ClientGet(K1=?) +o
.                    .                    <----------------------------------------+.
.                    .                    o+ GetReq(K1=?)      .                    .
.                    .      GetReq(K1=?) +o|                   .                    .
.                    .     GetReq(K1=?) +-o|                   .                    .
.                    .                  ||.+------------------->                    .
.                    .                  ||.      GetRsp(K1=1) +o                    .
.                    <-------------------+.                   |.                    .
.                    o+ GetRsp(K1=1)    | .                   |.                    .
.                    .|                 +->                   |.                    .
.                    .|     GetRsp(K1=1) +o                   |.                    .
.                    .|                  |<-------------------+.                    .
.                    .+------------------->                    .                    .
.                    .                   |o+ ClientGetRsp(K1=[1])                   .
.                    .                   +>|                   .                    .
.                    .                    .+---------------------------------------->
A                    B                    C                    D                    a
                   K1:1                 K1:1                 K1:1 </pre></div>


    <a name="failure"><h2>Coping With Failure</h2></a>
    <p>
      Nothing we've written so far copes with failure.  If just one node were to fail, then because <b>N</b>
      is 3 and (say) <b>W</b> is 2, we might just cope:
    </p>
<div class="highlight"><pre>
A                    B                    C                    D                    a
.                    .                    .                    .   ClientPut(K1=1) +o
<----------------------------------------------------------------------------------+.
++ ClientPut(K1=1)   .                    .                    .                    .
.|                 FAIL                   .                    .                    .
.+------------------------------------------------------------->                    .
.                    x                    .      PutReq(K1=1) +o                    .
.                    x                    .     PutReq(K1=1) +-o                    .
.                    x                    .    PutReq(K1=1) +--o                    .
.                    x                    .                 ||+>                    .
.                    x                    .      PutRsp(K1=1) +o                    .
.                    X---------------------------------------+|.                    .
.                    x                    <-----------------+ |.                    .
.                    x                    o+ PutRsp(K1=1)     |.                    .
.                    x                    .|                  +>                    .
.                    x                    .+------------------->                    .
.                    x                    .                    o+ ClientPutRsp(K1=1).
.                    x                    .                    .+------------------->
.                    x                    .                    .   ClientGet(K1=?) +o
.                    x                    <----------------------------------------+.
.                    x                    o+ GetReq(K1=?)      .                    .
.                    x      GetReq(K1=?) +o|                   .                    .
.                    x     GetReq(K1=?) +-o|                   .                    .
.                    x                  ||.+------------------->                    .
.                    x                  ||.      GetRsp(K1=1) +o                    .
.                    X-------------------+.                   |.                    .
.                    x                  +->                   |.                    .
.                    x      GetRsp(K1=1) +o                   |.                    .
.                    x                   |<-------------------+.                    .
.                    x                   +>                    .                    .
.                    x                    o+ ClientGetRsp(K1=[1])                   .
.                    x                    .+---------------------------------------->
A                    B                    C                    D                    a
                                        K1:1                 K1:1 </pre></div>
    <p>
      But if two nodes fail, then we're doomed:
    </p>
<div class="highlight"><pre>
B                C                D                a
.                .                ClientPut(K1=1) +o
.                .                <---------------+.
.                .  PutReq(K1=1) +o                .
.                . PutReq(K1=1) +-o                .
.                .PutReq(K1=1) +--o                .
FAIL             .             |||.                .
x              FAIL            |||.                .
x                x             ||+>                .
x                x  PutRsp(K1=1) +o                .
X-------------------------------+|.                .
x                X-------------+ |.                .
x                x               +>                .
B                C                D                a
                                K1:1 </pre></div>
    <p>
      Almost everything we still need to add to the code is about engineering around the consequences of
      failures:
    </p>
    <ul>
      <li><b>Failure Detection</b>: To begin with, we need to be able to spot failed nodes.</li>
      <li><b>Expanded Preference Lists</b>: Once a failed node has been spotted, we need to extend the
        replication set to cope.</li>
      <li><b>Failure Recovery Detection</b>: A failed node can recover, and we need some way to detect
        this.</li>
      <li><b>Catchup</b>: When a node recovers after a failure, it is out-of-sync and needs to catch up with
        the rest of the network.</li>
      <li><b>Detecting Divergence</b>: If a failure (particularly a network partition) resulted in the values
        for a particular key having inconsistent values, we need to detect this,
        using <a href="#vector_clock">vector clocks</a>.</li>
      <li><b>Repairing Divergence</b>: Once the values for a key have diverged, the Dynamo network isn't able
        to figure out how to repair the divergence itself, and so it has to push the problem up to the client
        software.</li>
    </ul>

    <a name="faildetect"><h2>Node Failure Detection (Section 4.8.3)</h2></a>
    <p>
      The first step in coping with failure is detecting it.  The message-sending framework we're using can
      automatically start a timer for any request message that is sent, and after a suitable period without a
      response, it can notify the original sender of the failure.  To use this facility, the sender just needs
      to include a <code>rsp_timer_pop</code> method in its class.
    </p>
    <p>
      To illustrate, here's the changes to the client to get it to resend any request on failure.  If there
      are multiple pending requests for the same failed destination node, we assume that they will all also
      fail, and resend them too.
    </p>
<div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">DynamoClientNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="o">+</span>     <span class="n">timer_priority</span> <span class="o">=</span> <span class="mi">17</span>
<span class="o">+</span> 
      <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">destnode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">destnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Pick a random node to send the request to</span>
              <span class="n">destnode</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">)</span>
          <span class="n">putmsg</span> <span class="o">=</span> <span class="n">ClientPut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destnode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
          <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
  
      <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">destnode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">destnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Pick a random node to send the request to</span>
              <span class="n">destnode</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">)</span>
          <span class="n">getmsg</span> <span class="o">=</span> <span class="n">ClientGet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destnode</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
          <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">getmsg</span><span class="p">)</span>
  
<span class="o">+</span>     <span class="k">def</span> <span class="nf">rsp_timer_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reqmsg</span><span class="p">):</span>
<span class="o">+</span>         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">,</span> <span class="n">ClientPut</span><span class="p">):</span>  <span class="c1"># retry</span>
<span class="o">+</span>             <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">reqmsg</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">reqmsg</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="o">+</span>         <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">,</span> <span class="n">ClientGet</span><span class="p">):</span>  <span class="c1"># retry</span>
<span class="o">+</span>             <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
<span class="o">+</span> 
</pre></div>

    <p>
      To show this in action, we can see what happens if the first receiving node fails; the client eventually
      retries and picks a different node at random.
    </p>
<div class="highlight"><pre>
A                    B                    C                    D                    a
.                    .                    .                    .   ClientPut(K1=1) +o
FAIL                 .                    .                    .                   |.
X----------------------------------------------------------------------------------+.
x                    .                    .                    .                Timer:Pop
x                    .                    .                    .   ClientPut(K1=1) +o
x                    .                    <----------------------------------------+.
x                    .                    o+ PutReq(K1=1)      .                    .
x                    .      PutReq(K1=1) +o|                   .                    .
x                    .     PutReq(K1=1) +-o|                   .                    .
x                    .                  ||.+------------------->                    .
x                    .                  ||.      PutRsp(K1=1) +o                    .
x                    <-------------------+.                   |.                    .
x                    o+ PutRsp(K1=1)    | .                   |.                    .
x                    .|                 +->                   |.                    .
x                    .|     PutRsp(K1=1) +o                   |.                    .
x                    .|                  |<-------------------+.                    .
x                    .+------------------->                    .                    .
x                    .                   |o+ ClientPutRsp(K1=1).                    .
x                    .                   +>|                   .                    .
x                    .                    .+---------------------------------------->
A                    B                    C                    D                    a
                   K1:1                 K1:1                 K1:1 </pre></div>

    <p>
      Inside the Dynamo network, each node keeps track of the requests it has outstanding, and when a request
      times out the destination node is marked as failed and the request is sent on to additional (hopefully
      working) nodes.
    </p>
<div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">DynamoNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="o">+</span>     <span class="n">timer_priority</span> <span class="o">=</span> <span class="mi">20</span>
      <span class="n">T</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Number of repeats for nodes in consistent hash table</span>
      <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Number of nodes to replicate at</span>
      <span class="n">W</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of nodes that need to reply to a write operation</span>
      <span class="n">R</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of nodes that need to reply to a read operation</span>
      <span class="n">nodelist</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">chash</span> <span class="o">=</span> <span class="n">ConsistentHashTable</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
  
      <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="nb">super</span><span class="p">(</span><span class="n">DynamoNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">local_store</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key =&gt; (value, metadata)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; set of nodes that have stored</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; original client message</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; set of (node, value, metadata) tuples</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># seqno =&gt; original client message</span>
<span class="o">+</span>         <span class="c1"># seqno =&gt; set of requests sent to other nodes, for each message class</span>
<span class="o">+</span>         <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span> <span class="o">=</span> <span class="p">{</span><span class="n">PutReq</span><span class="p">:</span> <span class="p">{},</span> <span class="n">GetReq</span><span class="p">:</span> <span class="p">{}}</span>
<span class="o">+</span>         <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span> <span class="o">=</span> <span class="p">[]</span>
          <span class="c1"># Rebuild the consistent hash table</span>
          <span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span> <span class="o">=</span> <span class="n">ConsistentHashTable</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
  
</pre></div>

    <p>
      Failed nodes are avoided in the preference list, both for <b>Put</b> operations:
    </p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_clientput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="o">-</span>         <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">+</span>         <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="err">?</span>                                                                            <span class="o">+++++++++++++++++++</span>

          <span class="c1"># Determine if we are in the list</span>
          <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
              <span class="c1"># Forward to the coordinator for this key</span>
              <span class="n">coordinator</span> <span class="o">=</span> <span class="n">preference_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
              <span class="n">Framework</span><span class="o">.</span><span class="n">forward_message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">coordinator</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="c1"># Use an incrementing local sequence number to distinguish</span>
              <span class="c1"># multiple requests for the same key</span>
              <span class="n">seqno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sequence_number</span><span class="p">()</span>
              <span class="n">metadata</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span>  <span class="c1"># For now, metadata is just sequence number at coordinator</span>
              <span class="c1"># Send out to preference list, and keep track of who has replied</span>
<span class="o">+</span>             <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
              <span class="n">reqcount</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
                  <span class="c1"># Send message to get node in preference list to store</span>
                  <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">)</span>
<span class="o">+</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                  <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                  <span class="n">reqcount</span> <span class="o">=</span> <span class="n">reqcount</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="k">if</span> <span class="n">reqcount</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                      <span class="c1"># preference_list may have more than N entries to allow for failed nodes</span>
                      <span class="k">break</span>
  
</pre></div>

    <p>and for <b>Get</b> operations:</p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_clientget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="o">-</span>         <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">+</span>         <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="err">?</span>                                                                            <span class="o">+++++++++++++++++++</span>

          <span class="c1"># Determine if we are in the list</span>
          <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
              <span class="c1"># Forward to the coordinator for this key</span>
              <span class="n">coordinator</span> <span class="o">=</span> <span class="n">preference_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
              <span class="n">Framework</span><span class="o">.</span><span class="n">forward_message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">coordinator</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="n">seqno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sequence_number</span><span class="p">()</span>
<span class="o">+</span>             <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">GetReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
              <span class="n">reqcount</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
                  <span class="n">getmsg</span> <span class="o">=</span> <span class="n">GetReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">)</span>
<span class="o">+</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">GetReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">getmsg</span><span class="p">)</span>
                  <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">getmsg</span><span class="p">)</span>
                  <span class="n">reqcount</span> <span class="o">=</span> <span class="n">reqcount</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="k">if</span> <span class="n">reqcount</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                      <span class="c1"># preference_list may have more than N entries to allow for failed nodes</span>
                      <span class="k">break</span>
  
</pre></div>

    <p>
      The code also needs to update the set of outstanding request when responses are received, both for <b>Put</b>:
    </p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_putrsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">putrsp</span><span class="p">):</span>
          <span class="n">seqno</span> <span class="o">=</span> <span class="n">putrsp</span><span class="o">.</span><span class="n">msg_id</span>
          <span class="k">if</span> <span class="n">seqno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">putrsp</span><span class="o">.</span><span class="n">from_node</span><span class="p">)</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">W</span><span class="p">:</span>
                  <span class="c1"># Tidy up tracking data structures</span>
                  <span class="n">original_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
<span class="o">+</span>                 <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span>
                  <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                  <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                  <span class="c1"># Reply to the original client</span>
                  <span class="n">client_putrsp</span> <span class="o">=</span> <span class="n">ClientPutRsp</span><span class="p">(</span><span class="n">original_msg</span><span class="p">)</span>
                  <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">client_putrsp</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="k">pass</span>  <span class="c1"># Superfluous reply</span>
  
</pre></div>

    <p>
      and <b>Get</b>:
    </p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_getrsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getrsp</span><span class="p">):</span>
          <span class="n">seqno</span> <span class="o">=</span> <span class="n">getrsp</span><span class="o">.</span><span class="n">msg_id</span>
          <span class="k">if</span> <span class="n">seqno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">getrsp</span><span class="o">.</span><span class="n">from_node</span><span class="p">,</span> <span class="n">getrsp</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">getrsp</span><span class="o">.</span><span class="n">metadata</span><span class="p">))</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">R</span><span class="p">:</span>
                  <span class="c1"># Build up all the distinct values/metadata values for the response to the original request</span>
                  <span class="n">results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]])</span>
                  <span class="c1"># Tidy up tracking data structures</span>
                  <span class="n">original_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
<span class="o">+</span>                 <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">GetReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span>
                  <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                  <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_get_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span>
                  <span class="c1"># Reply to the original client, including all received values</span>
                  <span class="n">client_getrsp</span> <span class="o">=</span> <span class="n">ClientGetRsp</span><span class="p">(</span><span class="n">original_msg</span><span class="p">,</span>
                                               <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">],</span>
                                               <span class="p">[</span><span class="n">metadata</span> <span class="k">for</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
                  <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">client_getrsp</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="k">pass</span>  <span class="c1"># Superfluous reply</span>
  
</pre></div>

    <p>
      A node gets treated as failed when some request to it times out. To keep the replication factors up to
      scratch, the timeout code also expands the set of nodes that the original request was sent to.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">rsp_timer_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reqmsg</span><span class="p">):</span>
        <span class="c1"># no response to this request; treat the destination node as failed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">to_node</span><span class="p">)</span>
        <span class="n">failed_requests</span> <span class="o">=</span> <span class="n">Framework</span><span class="o">.</span><span class="n">cancel_timers_to</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">to_node</span><span class="p">)</span>
        <span class="n">failed_requests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">failedmsg</span> <span class="ow">in</span> <span class="n">failed_requests</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">retry_request</span><span class="p">(</span><span class="n">failedmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">retry_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reqmsg</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">,</span> <span class="n">DynamoRequestMessage</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="c1"># Send the request to an additional node by regenerating the preference list</span>
        <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kls</span> <span class="o">=</span> <span class="n">reqmsg</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="c1"># Check the pending-request list for this type of request message</span>
        <span class="k">if</span> <span class="n">kls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span> <span class="ow">and</span> <span class="n">reqmsg</span><span class="o">.</span><span class="n">msg_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">kls</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">req</span><span class="o">.</span><span class="n">to_node</span> <span class="k">for</span> <span class="n">req</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">kls</span><span class="p">][</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">msg_id</span><span class="p">]]:</span>
                    <span class="c1"># Found a node on the new preference list that hasn&#39;t been sent the request.</span>
                    <span class="c1"># Send it a copy</span>
                    <span class="n">newreqmsg</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">)</span>
                    <span class="n">newreqmsg</span><span class="o">.</span><span class="n">to_node</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">kls</span><span class="p">][</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">msg_id</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newreqmsg</span><span class="p">)</span>
                    <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">newreqmsg</span><span class="p">)</span>
</pre></div>

    <p>
      With these modifications, the failures shown earlier start to look more recoverable from:
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
.                .                .                .                ClientPut(K1=1) +o
.                .                <-------------------------------------------------+.
.                .  PutReq(K1=1) +o                .                .                .
.                . PutReq(K1=1) +-o                .                .                .
.                .PutReq(K1=1) +--o                .                .                .
FAIL             .             |||.                .                .                .
x              FAIL            |||.                .                .                .
x                x             ||+>                .                .                .
x                x  PutRsp(K1=1) +o                .                .                .
X-------------------------------+|.                .                .                .
x                X-------------+ |.                .                .                .
x                x               +>                .                .                .
x                x            Timer:Pop            .                .                .
x                x                o+ PutReq(K1=1)  .                .                .
x                x                .+-------------------------------->                .
x                x                .                .  PutRsp(K1=1) +o                .
x                x                <--------------------------------+.                .
x                x                o+ ClientPutRsp(K1=1)             .                .
x                x                .+------------------------------------------------->
B                C                D                E                F                a
                                K1:1                              K1:1 </pre></div>
    <p>
      A subsequent request for the same key will skip the failed nodes automatically:
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
x                x                .                .                ClientPut(K1=2) +o
x                x                <-------------------------------------------------+.
x                x  PutReq(K1=2) +o                .                .                .
x                x               |o+ PutReq(K1=2)  .                .                .
x                x               |o-+ PutReq(K1=2) .                .                .
x                x               +>||              .                .                .
x                x  PutRsp(K1=2) +o||              .                .                .
x                x               |.+-------------------------------->                .
x                x               |. |              .  PutRsp(K1=2) +o                .
x                x               |. +-------------->               |.                .
x                x               |.  PutRsp(K1=2) +o               |.                .
x                x               +>               |.               |.                .
x                x                <--------------------------------+.                .
x                x                o+ ClientPutRsp(K1=2)             .                .
x                x                <---------------+.                .                .
x                x                .+------------------------------------------------->
B                C                D                E                F                a
                                K1:2             K1:2             K1:2 </pre></div>

    <a name="failrecover"><h2>Node Recovery Detection</h2></a>
    <p>
      Of course, nodes that have failed may recover.  To keep an eye out for this, we periodically check a
      node that has failed to see if it has recovered.
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">retry_failed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>  <span class="c1"># Permanently repeating timer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Send a test message to the oldest failed node</span>
            <span class="n">pingmsg</span> <span class="o">=</span> <span class="n">PingReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">pingmsg</span><span class="p">)</span>
        <span class="c1"># Restart the timer</span>
        <span class="n">TimerManager</span><span class="o">.</span><span class="n">start_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;retry&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">retry_failed_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rcv_pingreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pingmsg</span><span class="p">):</span>
        <span class="c1"># Always reply to a test message</span>
        <span class="n">pingrsp</span> <span class="o">=</span> <span class="n">PingRsp</span><span class="p">(</span><span class="n">pingmsg</span><span class="p">)</span>
        <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">pingrsp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rcv_pingrsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pingmsg</span><span class="p">):</span>
        <span class="c1"># Remove all instances of recovered node from failed node list</span>
        <span class="n">recovered_node</span> <span class="o">=</span> <span class="n">pingmsg</span><span class="o">.</span><span class="n">from_node</span>
        <span class="k">while</span> <span class="n">recovered_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">recovered_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recovered_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">[</span><span class="n">recovered_node</span><span class="p">]:</span>
                <span class="c1"># Send our latest value for this key</span>
                <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recovered_node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
                <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">[</span><span class="n">recovered_node</span><span class="p">]</span>
</pre></div>

    <p>
      This <b>Ping</b> request will likely fail at first, which will keep the node on the failed list.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
x                x            Timer:Pop            .                .                .
x                x       PingReq +o                .                .                .
X--------------------------------+.                .                .                .
B                C                D                E                F                a
                                K1:2             K1:2             K1:2 </pre></div>
    <p>
      But once a node recovers, some <b>Ping</b> will eventually succeed. However, a <b>Get</b> request after
      this recovery will not necessarily get the right answer: the different nodes that have been involved in
      storing values for the key along the way now have a different idea of what the most up-to-date value for
      that key is.  This means we'll need some way for the nodes to get back in sync.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
RECOVER          x                .                .                .                .
.             RECOVER             .                .                .                .
.                .            Timer:Pop            .                .                .
.                .       PingReq +o                .                .                .
<--------------------------------+.                .                .                .
o+ PingRsp       .                .                .                .                .
.+-------------------------------->                .                .                .
.                .            Timer:Pop            .                .                .
.                .       PingReq +o                .                .                .
.                <---------------+.                .                .                .
.                o+ PingRsp       .                .                .                .
.                .+--------------->                .                .                .
.                .                .                .                ClientGet(K1=?) +o
.                .                <-------------------------------------------------+.
.                .  GetReq(K1=?) +o                .                .                .
.                . GetReq(K1=?) +-o                .                .                .
.                .GetReq(K1=?) +--o                .                .                .
.                .             ||+>                .                .                .
.                .  GetRsp(K1=2) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ GetRsp(K1=None)             | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ GetRsp(K1=None)                .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientGetRsp(K1=[2, None])     .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
B                C                D                E                F                a
                                K1:2             K1:2             K1:2 </pre></div>
    <p>However, at this point a subsequent <b>Put</b> request will return to using the original preference list.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
RECOVER          x                .                .                .                .
.             RECOVER             .                .                .                .
.                .            Timer:Pop            .                .                .
.                .       PingReq +o                .                .                .
<--------------------------------+.                .                .                .
o+ PingRsp       .                .                .                .                .
.+-------------------------------->                .                .                .
.                .            Timer:Pop            .                .                .
.                .       PingReq +o                .                .                .
.                <---------------+.                .                .                .
.                o+ PingRsp       .                .                .                .
.                .+--------------->                .                .                .
.                .                .                .                ClientPut(K1=3) +o
.                .                <-------------------------------------------------+.
.                .  PutReq(K1=3) +o                .                .                .
.                . PutReq(K1=3) +-o                .                .                .
.                .PutReq(K1=3) +--o                .                .                .
.                .             ||+>                .                .                .
.                .  PutRsp(K1=3) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ PutRsp(K1=3)  .             | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ PutRsp(K1=3) |.                .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientPutRsp(K1=3)             .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
B                C                D                E                F                a
K1:3           K1:3             K1:3             K1:2             K1:2 </pre></div>

    <a name="hintedhandoff"><h2>Hinted Handoff</h2></a>
    <p>
      The most straightforward approach to restore synchronization is a <i>hinted handoff</i>:
      the extra node that received the <b>Put</b> operation gets told about the failed node that should have
      received the <b>Put</b> in the first place.  The extra node can then monitor the original node for
      liveness, and when it recovers send it the data that it missed.
    </p>
    <p>
      The first change to do this is at the sending node, filling in a <code>handoff</code> parameter on
      the <b>Put</b> message that is sent to the extra nodes.
    </p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_clientput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="o">-</span>         <span class="n">preference_list</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="err">?</span>                                                                                                <span class="o">---</span>

<span class="o">+</span>         <span class="n">preference_list</span><span class="p">,</span> <span class="n">avoided</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">)</span>
<span class="err">?</span>                        <span class="o">+++++++++</span>

<span class="o">+</span>         <span class="c1"># Only track avoided nodes that would have been part of the original preference list</span>
<span class="o">+</span>         <span class="n">avoided</span> <span class="o">=</span> <span class="n">avoided</span><span class="p">[:</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">]</span>
<span class="o">+</span>         <span class="n">non_extra_count</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">avoided</span><span class="p">)</span>
          <span class="c1"># Determine if we are in the list</span>
          <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
              <span class="c1"># Forward to the coordinator for this key</span>
              <span class="n">coordinator</span> <span class="o">=</span> <span class="n">preference_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
              <span class="n">Framework</span><span class="o">.</span><span class="n">forward_message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">coordinator</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="c1"># Use an incrementing local sequence number to distinguish</span>
              <span class="c1"># multiple requests for the same key</span>
              <span class="n">seqno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sequence_number</span><span class="p">()</span>
              <span class="n">metadata</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span>  <span class="c1"># For now, metadata is just sequence number at coordinator</span>
              <span class="c1"># Send out to preference list, and keep track of who has replied</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
              <span class="n">reqcount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">-</span>             <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
<span class="o">+</span>             <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">preference_list</span><span class="p">):</span>
<span class="err">?</span>                 <span class="o">++++</span>        <span class="o">++++++++++</span>               <span class="o">+</span>

<span class="o">+</span>                 <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;=</span> <span class="n">non_extra_count</span><span class="p">:</span>
<span class="o">+</span>                     <span class="c1"># This is an extra node that&#39;s only include because of a failed node</span>
<span class="o">+</span>                     <span class="n">handoff</span> <span class="o">=</span> <span class="n">avoided</span>
<span class="o">+</span>                 <span class="k">else</span><span class="p">:</span>
<span class="o">+</span>                     <span class="n">handoff</span> <span class="o">=</span> <span class="bp">None</span>
                  <span class="c1"># Send message to get node in preference list to store</span>
<span class="o">-</span>                 <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">)</span>
<span class="o">+</span>                 <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">,</span> <span class="n">handoff</span><span class="o">=</span><span class="n">handoff</span><span class="p">)</span>
<span class="err">?</span>                                                                                       <span class="o">+++++++++++++++++</span>

                  <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                  <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                  <span class="n">reqcount</span> <span class="o">=</span> <span class="n">reqcount</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="k">if</span> <span class="n">reqcount</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                      <span class="c1"># preference_list may have more than N entries to allow for failed nodes</span>
                      <span class="k">break</span>
  
</pre></div>

    <p>
      The next change is at the receiving node, which explictly starts to monitor the failed nodes for
      recovery, and tracks which keys need to be propagated on recovery.
    </p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">putmsg</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">putmsg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">putmsg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">putmsg</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
<span class="o">+</span>         <span class="k">if</span> <span class="n">putmsg</span><span class="o">.</span><span class="n">handoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
<span class="o">+</span>             <span class="k">for</span> <span class="n">failed_node</span> <span class="ow">in</span> <span class="n">putmsg</span><span class="o">.</span><span class="n">handoff</span><span class="p">:</span>
<span class="o">+</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">failed_node</span><span class="p">)</span>
<span class="o">+</span>                 <span class="k">if</span> <span class="n">failed_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">:</span>
<span class="o">+</span>                     <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">[</span><span class="n">failed_node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="o">+</span>                 <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">[</span><span class="n">failed_node</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">putmsg</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
          <span class="n">putrsp</span> <span class="o">=</span> <span class="n">PutRsp</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
          <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putrsp</span><span class="p">)</span>
  
</pre></div>

    <p>
      This results in the generation of some additional <b>Ping</b> messages.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
x                x                .                .                ClientPut(K1=2) +o
x                x                <-------------------------------------------------+.
x                x  PutReq(K1=2) +o                .                .                .
x                x               |o+ PutReq(K1=2, handoff=(B,C))    .                .
x                x               |o-+ PutReq(K1=2, handoff=(B,C))   .                .
x                x               +>||              .                .                .
x                x  PutRsp(K1=2) +o||              .                .                .
x                x               |.+-------------------------------->                .
x                x               |. |              .  PutRsp(K1=2) +o                .
x                x               |. +-------------->               |.                .
x                x               |.  PutRsp(K1=2) +o               |.                .
x                x               +>               |.               |.                .
x                x                <--------------------------------+.                .
x                x                o+ ClientPutRsp(K1=2)             .                .
x                x                <---------------+.                .                .
x                x                .+------------------------------------------------->
x                x            Timer:Pop            .                .                .
x                x       PingReq +o                .                .                .
X--------------------------------+.                .                .                .
x                x                .            Timer:Pop            .                .
x                x                .       PingReq +o                .                .
X-------------------------------------------------+.                .                .
x                x                .                .            Timer:Pop            .
x                x                .                .       PingReq +o                .
X------------------------------------------------------------------+.                .
x                x            Timer:Pop            .                .                .
x                x       PingReq +o                .                .                .
x                X---------------+.                .                .                .
B                C                D                E                F                a
                                K1:2             K1:2             K1:2 </pre></div>
    <p>
      Finally, when node recovery is detected, the appropriate <b>Put</b> messages to resynchronize the failed
      node's state are sent.
    </p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">retry_failed_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>  <span class="c1"># Permanently repeating timer</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">:</span>
              <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
              <span class="c1"># Send a test message to the oldest failed node</span>
              <span class="n">pingmsg</span> <span class="o">=</span> <span class="n">PingReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
              <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">pingmsg</span><span class="p">)</span>
          <span class="c1"># Restart the timer</span>
          <span class="n">TimerManager</span><span class="o">.</span><span class="n">start_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;retry&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">retry_failed_node</span><span class="p">)</span>
  
      <span class="k">def</span> <span class="nf">rcv_pingreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pingmsg</span><span class="p">):</span>
          <span class="c1"># Always reply to a test message</span>
          <span class="n">pingrsp</span> <span class="o">=</span> <span class="n">PingRsp</span><span class="p">(</span><span class="n">pingmsg</span><span class="p">)</span>
          <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">pingrsp</span><span class="p">)</span>
  
      <span class="k">def</span> <span class="nf">rcv_pingrsp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pingmsg</span><span class="p">):</span>
          <span class="c1"># Remove all instances of recovered node from failed node list</span>
          <span class="n">recovered_node</span> <span class="o">=</span> <span class="n">pingmsg</span><span class="o">.</span><span class="n">from_node</span>
          <span class="k">while</span> <span class="n">recovered_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">recovered_node</span><span class="p">)</span>
<span class="o">+</span>         <span class="k">if</span> <span class="n">recovered_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">:</span>
<span class="o">+</span>             <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">[</span><span class="n">recovered_node</span><span class="p">]:</span>
<span class="o">+</span>                 <span class="c1"># Send our latest value for this key</span>
<span class="o">+</span>                 <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="o">+</span>                 <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recovered_node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
<span class="o">+</span>                 <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
<span class="o">+</span>             <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending_handoffs</span><span class="p">[</span><span class="n">recovered_node</span><span class="p">]</span>
  
</pre></div>


    <p>
      This results in the recovered nodes discovering the state update that they'd missed out on.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
RECOVER          x                .                .                .                .
.             RECOVER             .                .                .                .
.                .                .            Timer:Pop            .                .
.                .                .       PingReq +o                .                .
.                <--------------------------------+.                .                .
.                o+ PingRsp       .                .                .                .
.                .+-------------------------------->                .                .
.                .                .  PutReq(K1=2) +o                .                .
.                <--------------------------------+.                .                .
.                o+ PutRsp(K1=2)  .                .                .                .
.                .+-------------------------------->                .                .
.                .                .                .            Timer:Pop            .
.                .                .                .       PingReq +o                .
.                <-------------------------------------------------+.                .
.                o+ PingRsp       .                .                .                .
.                .+------------------------------------------------->                .
.                .                .                .  PutReq(K1=2) +o                .
.                <-------------------------------------------------+.                .
.                o+ PutRsp(K1=2)  .                .                .                .
.                .+------------------------------------------------->                .
.                .            Timer:Pop            .                .                .
.                .       PingReq +o                .                .                .
<--------------------------------+.                .                .                .
o+ PingRsp       .                .                .                .                .
.+-------------------------------->                .                .                .
.                .                .            Timer:Pop            .                .
.                .                .       PingReq +o                .                .
<-------------------------------------------------+.                .                .
o+ PingRsp       .                .                .                .                .
.+------------------------------------------------->                .                .
.                .                .  PutReq(K1=2) +o                .                .
<-------------------------------------------------+.                .                .
o+ PutRsp(K1=2)  .                .                .                .                .
.+------------------------------------------------->                .                .
.                .                .                .            Timer:Pop            .
.                .                .                .       PingReq +o                .
<------------------------------------------------------------------+.                .
o+ PingRsp       .                .                .                .                .
.+------------------------------------------------------------------>                .
.                .                .                .  PutReq(K1=2) +o                .
<------------------------------------------------------------------+.                .
o+ PutRsp(K1=2)  .                .                .                .                .
.+------------------------------------------------------------------>                .
.                .            Timer:Pop            .                .                .
.                .       PingReq +o                .                .                .
.                <---------------+.                .                .                .
.                o+ PingRsp       .                .                .                .
.                .+--------------->                .                .                .
B                C                D                E                F                a
K1:2           K1:2             K1:2             K1:2             K1:2 </pre></div>

<!--
    <a name="merkle"><h2>Building Block: Merkle Trees (s4.7)</h2></a>
    <p>
      A Merkle tree is a tree structure describing a data set where
    </p>
    <ul>
      <li>each leaf node of the tree has a value that is the hash of some subset of the data</li>
      <li>each branch node of the tree is a hash of its children.</li>
    </ul>
    <p>
      This allows differences between two versions of the same data set to be detected quickly:
      <ul>
        <li>If the roots of two trees have the same hash value, all of the nodes below them in the tree must
          be the same</li>
        <li>If the roots of two trees have different hash values, we can recursively examine their children to
          locate the differences</li>
        <li>If two leaf nodes have different values, their data subsets differ</li>
      </ul>
    <p>
      The core of this data structure, dealing with non-leaf nodes, is fairly generic:
    </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MerkleTreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">recalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses should implement this method&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MerkleBranchNode</span><span class="p">(</span><span class="n">MerkleTreeNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interior node in Merkle tree&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MerkleBranchNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recalc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">recalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recalculate the Merkle value for this node, and all parent nodes&quot;&quot;&quot;</span>
        <span class="c1"># Node value is hash of two children&#39;s hash values concatenated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">recalc</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()[:</span><span class="mi">6</span><span class="p">]</span>
</pre></div>

    <p>
      The overall tree and the leaf nodes are more tailored to our particular problem.  The data set we are
      trying to keep in sync is the key-value store at a Dynamo node &ndash; or to be more specific, a
      subrange of the keyspace for that store.  To allow the subranges to be manipulated, first we set up a
      utility function that maps the MD5 hash of the key onto 128-bit integers.
    </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">keyhash</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a 128-bit integer associated with a key&quot;&quot;&quot;</span>
    <span class="n">hashval</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
    <span class="c1"># convert 128-bit MD5 value to long</span>
    <span class="k">return</span> <span class="nb">long</span><span class="p">(</span><span class="n">hashval</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
</pre></div>

    <p>
      Our overall tree covers a particular subrange of keys, and if the tree's depth is <b>D</b> we will have
      2<sup>D</sup> leaf nodes, each of which covers an sub-subrange of the keyspace.
    </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MerkleLeaf</span><span class="p">(</span><span class="n">MerkleTreeNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Leaf node in Merkle tree, encompassing all keys in subrange [min_key, max_key)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_key</span><span class="p">,</span> <span class="n">max_key</span><span class="p">,</span> <span class="n">initdata</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MerkleLeaf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_key</span> <span class="o">=</span> <span class="n">min_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_key</span> <span class="o">=</span> <span class="n">max_key</span>
        <span class="c1"># Copy in any keys whose hash falls in range for this node</span>
        <span class="k">if</span> <span class="n">initdata</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initdata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inrange</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)=&gt;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()[:</span><span class="mi">6</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_inrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine whether the given key falls within the subrange of this leaf node&quot;&quot;&quot;</span>
        <span class="n">hashval</span> <span class="o">=</span> <span class="n">keyhash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hashval</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_key</span> <span class="ow">and</span> <span class="n">hashval</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_key</span>

    <span class="k">def</span> <span class="nf">recalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recalculate the Merkle value for this node, and all parent nodes&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">recalc</span><span class="p">()</span>
</pre></div>

    <p>
      The overall <code>MerkleTree</code> class then builds the appropriate number of leaves, and their parents.
    </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MerkleTree</span><span class="p">(</span><span class="n">DictMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">min_key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_key</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">128</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">initdata</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a Merkle tree of given depth covering keys in range [min_key, max_key)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_key</span> <span class="o">=</span> <span class="n">min_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_key</span> <span class="o">=</span> <span class="n">max_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="c1"># There are 2^depth leaves in the tree.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_key</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_key</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span>

        <span class="c1"># nodes is an array of (depth+1) lists; each list is a layer of the tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># layer 0 (bottom) of the tree is (2^depth) leaf nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">MerkleLeaf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_key</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span><span class="p">,</span>
                                      <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_key</span> <span class="o">+</span> <span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span><span class="p">,</span>
                                          <span class="n">max_key</span><span class="p">),</span>
                                      <span class="n">initdata</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">)])</span>
        <span class="c1"># Each layer &gt;= 1 consists of interior nodes, and is half the size</span>
        <span class="c1"># of the layer below.  Each interior node is built from two nodes below it</span>
        <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">MerkleBranchNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ii</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                               <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

    <p>
      Given that we want to allow the data held in the tree to change, the ideal thing is for this data
      structure to appear like an ordinary Python <code>dict</code>.  Defining a useful <code>_findleaf</code>
      method allows us to set up all of the various container methods that
      <a href="http://docs.python.org/library/userdict.html#UserDict.DictMixin">allow this to happen</a>:
    </p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_findleaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index of the leaf node corresponding to the given key&quot;&quot;&quot;</span>
        <span class="n">hashval</span> <span class="o">=</span> <span class="n">keyhash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hashval</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_key</span> <span class="ow">or</span> <span class="n">hashval</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Key </span><span class="si">%s</span><span class="s2"> hashes to value outside range for this tree&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hashval</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">leafidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findleaf</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">recalc</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">leafidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findleaf</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">recalc</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">leafidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findleaf</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">leafidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findleaf</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leafidx</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">leafidx</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">leafidx</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">leafidx</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

    <p>
      With this, the Merkle tree looks like a normal <code>dict</code>.
    </p>
<div class="highlight"><pre>
>>> <b>from merkle import MerkleTree</b>
>>> <b>mtree = MerkleTree()</b>
>>> <b>mtree['a'] = 1</b>
>>> <b>mtree['b'] = 2</b>
>>> <b>print mtree['a']</b>
1
>>> <b>print mtree.root.value.hexdigest()</b>
a11a11376a4740025c337e58831f9207
>>> <b>del mtree['a']</b>
>>> <b>print 'a' in mtree</b>
False
>>> <b>print mtree.root.value.hexdigest()</b>
1f543830672d528ef3e9ef35f2c79a0b
</pre></div>


    <a name="catchup"><h2>Catchup</h2></a>
    ???
-->

    <a name="vector_clock"><h2>Building Block: Vector Clocks (s4.4)</h2></a>
    <p>
      A vector clock is easy to implement; it's basically a dictionary whose keys are nodes and whose values
      are the last-seen sequence number for that node.
    </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">VectorClock</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># node =&gt; counter</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new node:counter value to a VectorClock.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">%s</span><span class="s2"> has gone backwards from </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">counter</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
        <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># allow chaining of .update() operations</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
                                   <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
</pre></div>

    <p>
      We can add entries to the vector clock, simulating different nodes and their counters, with one proviso: a
      node's counter isn't allowed to go backwards.
    </p>
<div class="highlight"><pre>
>>> <b>from vectorclock import VectorClock</b>
>>> <b>v = VectorClock()</b>
>>> <b>print v</b>
{}
>>> <b>v.update('A', 1)</b>
>>> <b>print v</b>
{A:1}
>>> <b>v.update('A', 3)</b>
>>> <b>print v</b>
{A:3}
>>> <b>v.update('B', 1001)</b>
>>> <b>print v</b>
{A:3, B:1001}
>>> <b>v.update('B', 1002)</b>
>>> <b>print v</b>
{A:3, B:1002}
>>> <b>v.update('B', 1)</b>
Traceback (most recent call last):
  File "<string>", line 1, in <module>
  File "/usr/local/google/home/drysdale/src/pynamo/vectorclock.py", line 15, in update
    (node, self.clock[node], counter))
Exception: Node B has gone backwards from 1002 to 1
</pre></div>
    <p>
      We can also define an ordering operation <b>&lt;</b> on vector clocks
      (together with all the other comparison operations) by adding the relevant
      <a href="http://www.python.org/dev/peps/pep-0207/">rich comparison</a> methods
      to the <code>VectorClock</code> class.
    </p>
<div class="highlight"><pre><span></span>    <span class="c1"># Comparison operations. Vector clocks are partially ordered, but not totally ordered.</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">clock</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">clock</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">other</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

    <p>
      This is a <a href="http://en.wikipedia.org/wiki/Partially_ordered_set">partial order</a>:
    </p>
    <ul>
      <li>it's reflexive: <code>a &lt;= a</code> always holds (because <code>a==a</code>)</li>
      <li>it's antisymmetric: if <code>a &lt; b</code> and <code>b &lt; a</code>, then <code>a==b</code></li>
      <li>it's transitive: if <code>a &lt; b</code> and <code>b &lt; c</code>, then <code>a &lt;= c</code></li>
    </ul>
    <p>
      but it's not a <a href="http://en.wikipedia.org/wiki/Total_order">total order</a> &ndash; it's possible
      for neither <code>a &lt; b</code> nor <code>b &lt; a</code> to hold.
    </p>
<div class="highlight"><pre>
>>> <b>from vectorclock import VectorClock</b>
>>> <b>v1 = VectorClock().update('A', 1).update('B', 2)</b>
>>> <b>v2 = VectorClock().update('A', 2).update('B', 3)</b>
>>> <b>print (v1 < v2)</b>
True
>>> <b>v3 = VectorClock().update('X', 1).update('Y', 2)</b>
>>> <b>print (v1 < v3)</b>
False
>>> <b>print (v3 < v1)</b>
False
</pre></div>
    <p>
      This partial order forms the basis for the more important thing we can do with vector clocks &ndash;
      combine them.
    </p>
<div class="highlight"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Coalesce a container of VectorClock objects.</span>

<span class="sd">        The result is a list of VectorClocks; each input VectorClock is a direct</span>
<span class="sd">        ancestor of one of the results, and no result entry is a direct ancestor</span>
<span class="sd">        of any other result entry.&quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vc</span> <span class="ow">in</span> <span class="n">vcs</span><span class="p">:</span>
            <span class="c1"># See if this vector-clock subsumes or is subsumed by anything already present</span>
            <span class="n">subsumed</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vc</span> <span class="o">&lt;=</span> <span class="n">result</span><span class="p">:</span>  <span class="c1"># subsumed by existing answer</span>
                    <span class="n">subsumed</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">vc</span><span class="p">:</span>  <span class="c1"># subsumes existing answer so replace it</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span>
                    <span class="n">subsumed</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">subsumed</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">vc</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>
</pre></div>

    <p>
      This operation folds together those vector clocks that are direct ancestors of each other, but
      keeping separate those that are not.
    </p>
<div class="highlight"><pre>
>>> <b>print v1, v2, v3</b>
{A:1, B:2} {A:2, B:3} {X:1, Y:2}
>>> <b>diverged_clocks = VectorClock.coalesce((v1, v2, v3))</b>
>>> <b>for vc in diverged_clocks: print vc</b>
{A:2, B:3}
{X:1, Y:2}
>>> <b>print (diverged_clocks[0] < diverged_clocks[1])</b>
False
>>> <b>print (diverged_clocks[1] < diverged_clocks[0])</b>
False
</pre></div>
    <p>
      Finally, we need to be able to build a single vector clock that has an arbitrary set of direct
      ancestors; in other words, a way of reconverging a divergent set of vector clocks.
    </p>
<div class="highlight"><pre><span></span>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">converge</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">vcs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a single VectorClock that subsumes all of the input VectorClocks&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">vc</span> <span class="ow">in</span> <span class="n">vcs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">counter</span> <span class="ow">in</span> <span class="n">vc</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">clock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">counter</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>

    <p>
      The Dynamo system doesn't (and can't) solve the general problem of resolving inconsistencies; that's
      pushed out to the code that uses the system, and which is aware of the meaning of the data that is
      opaque to Dynamo.  But when that application code has resolved an inconsistency,
      this <code>converge</code> method builds a vector clock that makes it clear that the inconsistency
      has been resolved.
    </p>
<div class="highlight"><pre>
>>> <b>converged_clock = VectorClock.converge(diverged_clocks)</b>
>>> <b>print converged_clock</b>
{A:2, B:3, X:1, Y:2}
>>> <b>print (v1 < converged_clock)</b>
True
>>> <b>print (v2 < converged_clock)</b>
True
>>> <b>print (v3 < converged_clock)</b>
True
</pre></div>
    <p>
      The Dynamo paper also discusses the problem that the size of vector clocks can become large as more and
      more nodes get involved in the history of changes to a particular key/value.  To get around this, they
      suggest keeping a timestamp along with the sequence number, and throwing away the oldest entry in a
      vector clock when it has more than 10 entries.  This is easily implemented as a subclass
      of <code>VectorClock</code>, but we won't bother using this variant from here on.
    </p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;Vector clock class with truncation support&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">vectorclock</span> <span class="kn">import</span> <span class="n">VectorClock</span>


<span class="k">class</span> <span class="nc">VectorClockTimestamp</span><span class="p">(</span><span class="n">VectorClock</span><span class="p">):</span>
    <span class="n">NODE_LIMIT</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VectorClockTimestamp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock_time</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># node =&gt; timestamp</span>

    <span class="k">def</span> <span class="nf">_maybe_truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clock_time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">VectorClockTimestamp</span><span class="o">.</span><span class="n">NODE_LIMIT</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># Find the oldest entry</span>
        <span class="n">oldest_node</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">oldest_time</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">when</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock_time</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">oldest_time</span><span class="p">:</span>
                <span class="n">oldest_node</span> <span class="o">=</span> <span class="n">node</span>
                <span class="n">oldest_time</span> <span class="o">=</span> <span class="n">when</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock_time</span><span class="p">[</span><span class="n">oldest_node</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="n">oldest_node</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
        <span class="n">VectorClock</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock_time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_truncate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>

    <a name="divergence"><h2>Detecting Divergence</h2></a>
    <p>
      The vector clocks of the previous section allow Dynamo to detect when there have been distinct,
      inconsistent updates for a  particular key. The vector clock is held in the metadata associated with the
      key, and it is the responsibility of the Dynamo <b>client</b> to indicate the version of the data that
      it is updating.  In practical terms, this means that the client needs to preceded every <b>Put</b>
      operation with a <b>Get</b> operation to retrieve the appropriate metadata.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
.                .                .                .                ClientGet(K1=?) +o
.                .                <-------------------------------------------------+.
.                .  GetReq(K1=?) +o                .                .                .
.                . GetReq(K1=?) +-o                .                .                .
.                .GetReq(K1=?) +--o                .                .                .
.                .             ||+>                .                .                .
.           GetRsp(K1=None@None) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ GetRsp(K1=None@None)        | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ GetRsp(K1=None@None)           .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientGetRsp(K1=[None]@[{}])   .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
.                .                .                .             ClientPut(K1=1@{}) +o
.                .                <-------------------------------------------------+.
.             PutReq(K1=1@{D:2}) +o                .                .                .
.            PutReq(K1=1@{D:2}) +-o                .                .                .
.           PutReq(K1=1@{D:2}) +--o                .                .                .
.                .             ||+>                .                .                .
.             PutRsp(K1=1@{D:2}) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ PutRsp(K1=1@{D:2})          | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ PutRsp(K1=1@{D:2})             .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientPutRsp(K1=1@{D:2})       .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
.                .                .                .                ClientGet(K1=?) +o
.                .                <-------------------------------------------------+.
.                .  GetReq(K1=?) +o                .                .                .
.                . GetReq(K1=?) +-o                .                .                .
.                .GetReq(K1=?) +--o                .                .                .
.                .             ||+>                .                .                .
.             GetRsp(K1=1@{D:2}) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ GetRsp(K1=1@{D:2})          | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ GetRsp(K1=1@{D:2})             .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientGetRsp(K1=[1]@[{D:2}])   .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
.                .                .                .          ClientPut(K1=2@{D:2}) +o
.                .                <-------------------------------------------------+.
.             PutReq(K1=2@{D:4}) +o                .                .                .
.            PutReq(K1=2@{D:4}) +-o                .                .                .
.           PutReq(K1=2@{D:4}) +--o                .                .                .
.                .             ||+>                .                .                .
.             PutRsp(K1=2@{D:4}) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ PutRsp(K1=2@{D:4})          | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ PutRsp(K1=2@{D:4})             .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientPutRsp(K1=2@{D:4})       .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
B                C                D                E                F                a
K1:2           K1:2             K1:2 </pre></div>
    <p>
      For convenience, to cope with the situation where a client holds on to a key and makes multiple updates,
      we also return the new metadata on a <b>Put</b> response so it can be used for a subsequent <b>Put</b>:
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
.                .                .                .                ClientGet(K1=?) +o
.                .                <-------------------------------------------------+.
.                .  GetReq(K1=?) +o                .                .                .
.                . GetReq(K1=?) +-o                .                .                .
.                .GetReq(K1=?) +--o                .                .                .
.                .             ||+>                .                .                .
.             GetRsp(K1=2@{D:4}) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ GetRsp(K1=2@{D:4})          | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ GetRsp(K1=2@{D:4})             .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientGetRsp(K1=[2]@[{D:4}])   .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
.                .                .                .          ClientPut(K1=3@{D:4}) +o
.                .                <-------------------------------------------------+.
.             PutReq(K1=3@{D:6}) +o                .                .                .
.            PutReq(K1=3@{D:6}) +-o                .                .                .
.           PutReq(K1=3@{D:6}) +--o                .                .                .
.                .             ||+>                .                .                .
.             PutRsp(K1=3@{D:6}) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ PutRsp(K1=3@{D:6})          | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ PutRsp(K1=3@{D:6})             .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientPutRsp(K1=3@{D:6})       .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
.                .                .                .          ClientPut(K1=4@{D:6}) +o
.                .                <-------------------------------------------------+.
.             PutReq(K1=4@{D:7}) +o                .                .                .
.            PutReq(K1=4@{D:7}) +-o                .                .                .
.           PutReq(K1=4@{D:7}) +--o                .                .                .
.                .             ||+>                .                .                .
.             PutRsp(K1=4@{D:7}) +o                .                .                .
<-------------------------------+|.                .                .                .
o+ PutRsp(K1=4@{D:7})          | |.                .                .                .
.|               <-------------+ |.                .                .                .
.|               o+ PutRsp(K1=4@{D:7})             .                .                .
.|               .|              +>                .                .                .
.+-------------------------------->                .                .                .
.                .|               o+ ClientPutRsp(K1=4@{D:7})       .                .
.                .+--------------->|               .                .                .
.                .                .+------------------------------------------------->
B                C                D                E                F                a
K1:4           K1:4             K1:4 </pre></div>
    <p>
      The Dynamo node that acts as the coordinator for the key updates the vector clock with its own sequence
      numbers:
    </p>
    <p>
<div class="highlight"><pre><span></span>      <span class="k">def</span> <span class="nf">rcv_clientput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
          <span class="n">preference_list</span><span class="p">,</span> <span class="n">avoided</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">chash</span><span class="o">.</span><span class="n">find_nodes</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_nodes</span><span class="p">)</span>
          <span class="c1"># Only track avoided nodes that would have been part of the original preference list</span>
          <span class="n">avoided</span> <span class="o">=</span> <span class="n">avoided</span><span class="p">[:</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">]</span>
          <span class="n">non_extra_count</span> <span class="o">=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">avoided</span><span class="p">)</span>
          <span class="c1"># Determine if we are in the list</span>
          <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preference_list</span><span class="p">:</span>
              <span class="c1"># Forward to the coordinator for this key</span>
              <span class="n">coordinator</span> <span class="o">=</span> <span class="n">preference_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
              <span class="n">Framework</span><span class="o">.</span><span class="n">forward_message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">coordinator</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="c1"># Use an incrementing local sequence number to distinguish</span>
              <span class="c1"># multiple requests for the same key</span>
              <span class="n">seqno</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sequence_number</span><span class="p">()</span>
<span class="o">-</span>             <span class="n">metadata</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span>  <span class="c1"># For now, metadata is just sequence number at coordinator</span>
<span class="o">+</span>             <span class="c1"># The metadata for a key is passed in by the client, and updated by the coordinator node.</span>
<span class="o">+</span>             <span class="n">metadata</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
<span class="o">+</span>             <span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span>
              <span class="c1"># Send out to preference list, and keep track of who has replied</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_rsp</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">pending_put_msg</span><span class="p">[</span><span class="n">seqno</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
              <span class="n">reqcount</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">preference_list</span><span class="p">):</span>
                  <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;=</span> <span class="n">non_extra_count</span><span class="p">:</span>
                      <span class="c1"># This is an extra node that&#39;s only include because of a failed node</span>
                      <span class="n">handoff</span> <span class="o">=</span> <span class="n">avoided</span>
                  <span class="k">else</span><span class="p">:</span>
                      <span class="n">handoff</span> <span class="o">=</span> <span class="bp">None</span>
                  <span class="c1"># Send message to get node in preference list to store</span>
                  <span class="n">putmsg</span> <span class="o">=</span> <span class="n">PutReq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">msg_id</span><span class="o">=</span><span class="n">seqno</span><span class="p">,</span> <span class="n">handoff</span><span class="o">=</span><span class="n">handoff</span><span class="p">)</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">pending_req</span><span class="p">[</span><span class="n">PutReq</span><span class="p">][</span><span class="n">seqno</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                  <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
                  <span class="n">reqcount</span> <span class="o">=</span> <span class="n">reqcount</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="k">if</span> <span class="n">reqcount</span> <span class="o">&gt;=</span> <span class="n">DynamoNode</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                      <span class="c1"># preference_list may have more than N entries to allow for failed nodes</span>
                      <span class="k">break</span>
  
</pre></div>

    <p>
      For a straightforward node failure, the vector clock doesn't really add anything.  Continuing from the
      sequences above, a subsequent <b>Put</b> then a <b>Get</b> still return a single consistent value
      &ndash; albeit with a vector clock that indicates multiple Dynamo nodes have been involved in the
      history of this key.
    </p>
<div class="highlight"><pre>
B                C                D                E                F                a
.                .              FAIL               .                .                .
.                .                x                .         ClientPut(K1=11@{D:7}) +o
<-----------------------------------------------------------------------------------+.
o+ PutReq(K1=11@{B:1, D:7})       x                .                .                .
o-+ PutReq(K1=11@{B:1, D:7})      x                .                .                .
o--+ PutReq(K1=11@{B:1, D:7})     x                .                .                .
.+--------------------------------X                .                .                .
<-+|             .                x                .                .                .
o+ PutRsp(K1=11@{B:1, D:7})       x                .                .                .
.| +------------->                x                .                .                .
.|              +o PutRsp(K1=11@{B:1, D:7})        .                .                .
<+              |.                x                .                .                .
<---------------+.                x                .                .                .
o+ ClientPutRsp(K1=11@{B:1, D:7}) x                .                .                .
.+----------------------------------------------------------------------------------->
.                .                x                .                ClientGet(K1=?) +o
<-----------------------------------------------------------------------------------+.
o+ GetReq(K1=?)  .                x                .                .                .
o-+ GetReq(K1=?) .                x                .                .                .
o--+ GetReq(K1=?).                x                .                .                .
.+--------------------------------X                .                .                .
<-+|             .                x                .                .                .
o+ GetRsp(K1=11@{B:1, D:7})       x                .                .                .
.| +------------->                x                .                .                .
.|              +o GetRsp(K1=11@{B:1, D:7})        .                .                .
<+              |.                x                .                .                .
<---------------+.                x                .                .                .
o+ ClientGetRsp(K1=[11]@[{B:1, D:7}])              .                .                .
.+----------------------------------------------------------------------------------->
B                C                D                E                F                a
K1:11          K1:11            K1:4 </pre></div>
    <p>
      Of course, it's not just nodes that can fail &ndash; sometimes, the links between them fail too.  The
      worst scenario that this leads to is <i>network partition</i>: half of the network is on one side of the
      partition, the other half is on the other side, and never the twain shall meet.
      Network partitions are particularly bad because different clients can update keys on the either side of
      the partition, resulting in different, incompatible, values for the keys.
    </p>
<div class="highlight"><pre>
b                A                B                C                D                E                F                a
.                .                .                .                .                .                ClientGet(K1=?) +o
.                .                .                .                <-------------------------------------------------+.
.                .                .                .  GetReq(K1=?) +o                .                .                .
.                .                .                . GetReq(K1=?) +-o                .                .                .
.                .                .                .GetReq(K1=?) +--o                .                .                .
.                .                .                .             ||+>                .                .                .
.                .                .           GetRsp(K1=None@None) +o                .                .                .
.                .                <-------------------------------+|.                .                .                .
.                .                o+ GetRsp(K1=None@None)        | |.                .                .                .
.                .                .|               <-------------+ |.                .                .                .
.                .                .|               o+ GetRsp(K1=None@None)           .                .                .
.                .                .|               .|              +>                .                .                .
.                .                .+-------------------------------->                .                .                .
.                .                .                .|               o+ ClientGetRsp(K1=[None]@[{}])   .                .
.                .                .                .+--------------->|               .                .                .
.                .                .                .                .+------------------------------------------------->
.                .                .                .                .                .             ClientPut(K1=1@{}) +o
.                .                .                .                <-------------------------------------------------+.
.                .                .             PutReq(K1=1@{D:2}) +o                .                .                .
.                .                .            PutReq(K1=1@{D:2}) +-o                .                .                .
.                .                .           PutReq(K1=1@{D:2}) +--o                .                .                .
.                .                .                .             ||+>                .                .                .
.                .                .             PutRsp(K1=1@{D:2}) +o                .                .                .
.                .                <-------------------------------+|.                .                .                .
.                .                o+ PutRsp(K1=1@{D:2})          | |.                .                .                .
.                .                .|               <-------------+ |.                .                .                .
.                .                .|               o+ PutRsp(K1=1@{D:2})             .                .                .
.                .                .|               .|              +>                .                .                .
.                .                .+-------------------------------->                .                .                .
.                .                .                .|               o+ ClientPutRsp(K1=1@{D:2})       .                .
.                .                .                .+--------------->|               .                .                .
.                .                .                .                .+------------------------------------------------->
 ********************************** Cut ['b', 'A', 'B', 'C'] -> ['D', 'E', 'F', 'a'] ********************************** 
 ********************************** Cut ['D', 'E', 'F', 'a'] -> ['b', 'A', 'B', 'C'] ********************************** 
.                .                .                .                .                .         ClientPut(K1=11@{D:2}) +o
.                .                .                .                <-------------------------------------------------+.
.                .                .            PutReq(K1=11@{D:3}) +o                .                .                .
.                .                .           PutReq(K1=11@{D:3}) +-o                .                .                .
.                .                .          PutReq(K1=11@{D:3}) +--o                .                .                .
.                .                .                .             ||+>                .                .                .
.                .                .            PutRsp(K1=11@{D:3}) +o                .                .                .
.                .                .                .             |X|.                .                .                .
.                .                .                .             X |.                .                .                .
.                .                .                .               +>                .                .                .
.                .                .                .            Timer:Pop            .                .                .
.                .                .                .                o+ PutReq(K1=11@{D:3})            .                .
.                .                .                .                .+-------------------------------->                .
.                .                .                .                .            PutRsp(K1=11@{D:3}) +o                .
.                .                .                .                <--------------------------------+.                .
.                .                .                .                o+ ClientPutRsp(K1=11@{D:3})      .                .
.                .                .                .                .+------------------------------------------------->
.                .                .                .            Timer:Pop            .                .                .
o+ ClientGet(K1=?)                .                .                .                .                .                .
.X               .                .                .                .                .                .                .
Timer:Pop        .                .                .                .                .                .                .
o+ ClientGet(K1=?)                .                .                .                .                .                .
.+-------------------------------->                .                .                .                .                .
.                .                o+ GetReq(K1=?)  .                .                .                .                .
.                .  GetReq(K1=?) +o|               .                .                .                .                .
.                .               |o-+ GetReq(K1=?) .                .                .                .                .
.                .               |.X|              .                .                .                .                .
.                .               +> |              .                .                .                .                .
.             GetRsp(K1=1@{D:2}) +o |              .                .                .                .                .
.                .               |. +-------------->                .                .                .                .
.                .             GetRsp(K1=1@{D:2}) +o                .                .                .                .
.                .               +>               |.                .                .                .                .
.                .                <---------------+.                .                .                .                .
.   ClientGetRsp(K1=[1]@[{D:2}]) +o                .                .                .                .                .
<--------------------------------+.                .                .                .                .                .
.                .            Timer:Pop            .                .                .                .                .
o+ ClientPut(K1=21@{D:2})         .                .                .                .                .                .
.+--------------->                .                .                .                .                .                .
.                ++ ClientPut(K1=21@{D:2})         .                .                .                .                .
.                .X               .                .                .                .                .                .
Timer:Pop        .                .                .                .                .                .                .
o+ ClientPut(K1=21@{D:2})         .                .                .                .                .                .
.+------------------------------------------------->                .                .                .                .
.                .                .                o+ PutReq(K1=21@{C:1, D:2})       .                .                .
.                .       PutReq(K1=21@{C:1, D:2}) +o|               .                .                .                .
.                .      PutReq(K1=21@{C:1, D:2}) +-o|               .                .                .                .
.                .                .              ||.X               .                .                .                .
.                .                <---------------+.                .                .                .                .
.                .                o+ PutRsp(K1=21@{C:1, D:2})       .                .                .                .
.                .                .|             +->                .                .                .                .
.                .       PutRsp(K1=21@{C:1, D:2}) +o                .                .                .                .
.                .                .+--------------->                .                .                .                .
.                .                .               +>                .                .                .                .
.                . ClientPutRsp(K1=21@{C:1, D:2}) +o                .                .                .                .
<-------------------------------------------------+.                .                .                .                .
b                A                B                C                D                E                F                a
                                K1:21            K1:21            K1:11                             K1:11 </pre></div>
    <p>
      This is where the vector clock helps; after the network is repaired, the next <b>Get</b> operation
      returns a divergent set of metadata &ndash; <b><code>
[11, 21]@[{D:3},{C:1, D:2}]       </code></b> indicating two possible values for the key, with two associated vector clocks.
      This indicates that there are inconsistent values for the key that
      need to be dealt with.
    </p>
<div class="highlight"><pre>
b                A                B                C                D                E                F                a
 ********************************************** Repair network partition ********************************************** 
.                .            Timer:Pop            .                .                .                .                .
.                .                o+ PingReq       .                .                .                .                .
.                .                .+-------------------------------->                .                .                .
.                .                .                .       PingRsp +o                .                .                .
.                .                <--------------------------------+.                .                .                .
.                .                .            Timer:Pop            .                .                .                .
.                .                .                o+ PingReq       .                .                .                .
.                .                .                .+--------------->                .                .                .
.                .                .                .       PingRsp +o                .                .                .
.                .                .                <---------------+.                .                .                .
.                .                .                .            Timer:Pop            .                .                .
.                .                .                .       PingReq +o                .                .                .
.                .                <--------------------------------+.                .                .                .
.                .                o+ PingRsp       .                .                .                .                .
.                .                .+-------------------------------->                .                .                .
.                .                .                .            Timer:Pop            .                .                .
.                .                .                .       PingReq +o                .                .                .
.                .                .                <---------------+.                .                .                .
.                .                .                o+ PingRsp       .                .                .                .
.                .                .                .+--------------->                .                .                .
.                .                .                .                .                .                ClientGet(K1=?) +o
.                .                .                <------------------------------------------------------------------+.
.                .                .                o+ GetReq(K1=?)  .                .                .                .
.                .                .  GetReq(K1=?) +o|               .                .                .                .
.                .                . GetReq(K1=?) +-o|               .                .                .                .
.                .                .              ||.+--------------->                .                .                .
.                .                .            GetRsp(K1=11@{D:3}) +o                .                .                .
.                .                <---------------+.               |.                .                .                .
.                .                o+ GetRsp(K1=21@{C:1, D:2})      |.                .                .                .
.                .                .|             +->               |.                .                .                .
.                .       GetRsp(K1=21@{C:1, D:2}) +o               |.                .                .                .
.                .                .|              |<---------------+.                .                .                .
.                .                .+--------------->                .                .                .                .
.                .                .               |o+ ClientGetRsp(K1=[11, 21]@[{D:3},{C:1, D:2}])    .                .
.                .                .               +>|               .                .                .                .
.                .                .                .+------------------------------------------------------------------>
b                A                B                C                D                E                F                a
                                K1:21            K1:21            K1:11                             K1:11 </pre></div>

    <a name="divergence_repair"><h2>Repairing Divergence</h2></a>
    <p>
      The data stored by Dynamo is opaque to the system, which means that Dynamo itself has no way of figuring
      out how to deal with the inconsistent data.  Therefore, the problem is pushed out to the client: the
      client has to figure it out, and the next <b>Put</b> message that includes a divergent set of vector
      clocks is assumed to subsume them all.
    </p>
<div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">DynamoClientNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
      <span class="n">timer_priority</span> <span class="o">=</span> <span class="mi">17</span>
<span class="o">+</span> 
<span class="o">+</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="o">+</span>         <span class="nb">super</span><span class="p">(</span><span class="n">DynamoClientNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="o">+</span>         <span class="bp">self</span><span class="o">.</span><span class="n">last_msg</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Track last received message</span>
  
      <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">destnode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">destnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Pick a random node to send the request to</span>
              <span class="n">destnode</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">)</span>
<span class="o">+</span>         <span class="c1"># Input metadata is always a sequence, but we always need to insert a</span>
<span class="o">+</span>         <span class="c1"># single VectorClock object into the ClientPut message</span>
<span class="o">+</span>         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">metadata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="o">+</span>             <span class="n">metadata</span> <span class="o">=</span> <span class="n">VectorClock</span><span class="p">()</span>
<span class="o">+</span>         <span class="k">else</span><span class="p">:</span>
<span class="o">+</span>             <span class="c1"># A Put operation always implies convergence</span>
<span class="o">+</span>             <span class="n">metadata</span> <span class="o">=</span> <span class="n">VectorClock</span><span class="o">.</span><span class="n">converge</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
          <span class="n">putmsg</span> <span class="o">=</span> <span class="n">ClientPut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destnode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
          <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">putmsg</span><span class="p">)</span>
<span class="o">+</span>         <span class="k">return</span> <span class="n">putmsg</span>
  
      <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">destnode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">destnode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Pick a random node to send the request to</span>
              <span class="n">destnode</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">DynamoNode</span><span class="o">.</span><span class="n">nodelist</span><span class="p">)</span>
          <span class="n">getmsg</span> <span class="o">=</span> <span class="n">ClientGet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destnode</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
          <span class="n">Framework</span><span class="o">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">getmsg</span><span class="p">)</span>
<span class="o">+</span>         <span class="k">return</span> <span class="n">getmsg</span>
  
      <span class="k">def</span> <span class="nf">rsp_timer_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reqmsg</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">,</span> <span class="n">ClientPut</span><span class="p">):</span>  <span class="c1"># retry</span>
<span class="o">-</span>             <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">reqmsg</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">reqmsg</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="o">+</span>             <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">metadata</span><span class="p">],</span> <span class="n">reqmsg</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="err">?</span>                                  <span class="o">+</span>               <span class="o">+</span>

          <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reqmsg</span><span class="p">,</span> <span class="n">ClientGet</span><span class="p">):</span>  <span class="c1"># retry</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reqmsg</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
  
</pre></div>

    <p>
      Following on from the sequences of the last section, this results in a <b>Put</b> operation with a
      single converged vector clock <b><code>
{C:1, D:3}       </b></code>.
    </p>
<div class="highlight"><pre>
b                A                B                C                D                E                F                a
.                .                .                .                .                .   ClientPut(K1=101@{C:1, D:3}) +o
.                .                .                .                .                .                <---------------+.
.                .                .                .                .   ClientPut(K1=101@{C:1, D:3}) ++                .
.                .                .                .                <--------------------------------+.                .
.                .                .      PutReq(K1=101@{C:1, D:4}) +o                .                .                .
.                .                .     PutReq(K1=101@{C:1, D:4}) +-o                .                .                .
.                .                .    PutReq(K1=101@{C:1, D:4}) +--o                .                .                .
.                .                .                .             ||+>                .                .                .
.                .                .      PutRsp(K1=101@{C:1, D:4}) +o                .                .                .
.                .                <-------------------------------+|.                .                .                .
.                .                o+ PutRsp(K1=101@{C:1, D:4})   | |.                .                .                .
.                .                .|               <-------------+ |.                .                .                .
.                .                .|               o+ PutRsp(K1=101@{C:1, D:4})      .                .                .
.                .                .|               .|              +>                .                .                .
.                .                .+-------------------------------->                .                .                .
.                .                .                .|               o+ ClientPutRsp(K1=101@{C:1, D:4}).                .
.                .                .                .+--------------->|               .                .                .
.                .                .                .                .+------------------------------------------------->
b                A                B                C                D                E                F                a
                               K1:101           K1:101           K1:101                             K1:11 </pre></div>

    <a name="rest"><h2>What's Left</h2></a>
    <blockquote>
      <i>In theory, there's no difference between theory and practice. In practice there is.</i>
    </blockquote>
    <p>
      We've implemented some of the key ideas from the Dynamo paper here, but we haven't implemented
      everything in the paper.  There's a summary of the parts we've skipped below; the length of this list
      gives an indication of just how many reality-based complications are involved in turning Dynamo into 
      a real implementation.
    </p>
    <ul>
      <li><b>Anti-entropy with Merkle trees</b>: In the long run, nodes will drift out of synchronization.  A 
        <a href="http://en.wikipedia.org/wiki/Hash_tree">Merkle tree</a> can be used to maintain
        synchronization for shared key ranges.</li>
      <li><b>Deletion after hinted handoff</b>: Once a <a href="#hintedhandoff">hinted handoff</a>
        has completed and the original node from the preference list has taken the data, the additional node
        could delete its superfluous copy of the data (section 4.6).</li>
      <li><b>Node membership synchronization</b>: Because the system here is simulated, any
        additions or removals of a node are instantly visible to all other nodes in the system.  This means
        that we don't have to worry about the real-world concern of keeping knowledge about the potential set
        of nodes in sync.  Section 4.8 of the Dynamo paper
        describes <a href="http://en.wikipedia.org/wiki/Gossip_protocol">gossip</a>-based systems for doing this in a
        real, asynchronous set of nodes.</li>
      <li><b>Divergence repair using timestamps</b>: One possibility for automatic divergence repair is just
        to allow "last timestamp wins" (section 6).</li>
      <li><b>Vector clock truncation by timestamp</b>: Vector clocks have unbounded growth as the set of nodes
        in the system varies over time.  This can be ameliorated by using timestamps to limit growth described in
        (section 4.4)</li>
      <li><b>Client operation timeouts</b>: In this simulated system, client requests are retried forever
        rather than giving up and returning an error to the client (section 5).</li>
      <li><b>Read repair</b>: If a <b>Get</b> response arrives just after quorum has been reached (and
        the <b>ClientGet</b> response returned), and has an inconsistent value for the key, the read coordinator
        node could update the laggy node with latest (quorum) value for the key (section 5).</li>
      <li><b>Coordinator chosen for speed</b>: Given the prevalence of get-then-put sequences, the coordinator
      for a <b>Put</b> could be chosen to be the node that responded fastest to the <b>Get</b> (section 5)</li>
      <li><b>Alternative load distribution strategies</b>: Section 6.2 of the paper gives two other strategies (2 and 3)
        for consistent hash distribution.</li>
      <li><b>Differing prioritizations</b>: Foreground (i.e. client-driven) and background (repair,
      synchronization) tasks could be assigned different scheduling priorities (section 6.5)</li>
    </ul>

    <a name="framework"><h2>Appendix: Node Simulation Framework</h2></a>
    <p>
      The code here is built on a framework that simulates nodes and the messages between them.  The modules
      for this are divided up as follows.
    </p>
    <ul>
      <li><code>framework.py</code>: Master code for scheduling and tracking nodes and messages, mostly in the
      <code>Framework</code> class.</li>
      <li><code>history.py</code>: Code to track a list of events (messages sent/received, timers start/stop
      etc) and generate sequence diagrams from them. Mostly encapsulated in the <code>History</code> class.</li>
      <li><code>timer.py</code>: Code to manage pending timers, via the <code>TimerManager</code> class.</li>
      <li><code>testutils.py</code>: Utilities for unit tests, mostly statistics (<code>Statistics</code> class).</li>
      <li><code>logconfig.py</code>: Initialization for logging.</li>
      <li><code>message.py</code>: Base classes for message structures.</li>
    </ul>
    <a name="epilog"><h2>Epilog: Code Location &amp; Licenses</h2></a>
    <p>
      A full copy of this project (text, source, scripts) can be downloaded
      at <a href="https://github.com/daviddrysdale/pynamo">GitHub</a> or downloads as a
      <a href="http://lurklurk.org/pynamo/pynamo.tgz">tarball here</a>.  The text is available under
      the <a href="http://www.gnu.org/licenses/fdl.html">GFDL 1.3</a>, the code is available under
      <a href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">version 2 of the GPL</a>.
      <hr>
    <p>Copyright (c) 2010-2012, David Drysdale</p>

    <p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free
      Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with
      no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the license
      is available
      <a href="http://www.gnu.org/copyleft/fdl.html">here</a>.</p>
    <hr>
    <p><a href="http://www.lurklurk.org/">Back to Home Page</a></p>
    <hr>
    <p><a href="mailto:dmd at_sign_here lurklurk dot_here org">Contact me</a></p>
  </body>
</html>
